Декоратор (шаблон проектирования)
	Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения 
	дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания 
	подклассов с целью расширения функциональности.

Задача 
	Объект, который предполагается использовать, выполняет основные функции. Однако может потребоваться 
добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или 
даже вместо основной функциональности объекта.

Способ решения
	Декоратор предусматривает расширение функциональности объекта без определения подклассов.
-----------------------------------------------------------------------------------------------------------------------------------
Участники:
	Класс ConcreteComponent — класс, в который с помощью шаблона Декоратор добавляется новая функциональность. 
В некоторых случаях базовая функциональность предоставляется классами, производными от класса ConcreteComponent. 
В подобных случаях класс ConcreteComponent является уже не конкретным, а абстрактным. 
	Абстрактный класс Component определяет интерфейс для использования всех этих классов.
-----------------------------------------------------------------------------------------------------------------------------------
Участники:
	Component: абстрактный класс, который определяет интерфейс для наследуемых объектов.
	ConcreteComponent: конкретная реализация компонента, в которую с помощью декоратора добавляется новая функциональность.
	Decorator: собственно декоратор, реализуется в виде абстрактного класса и имеет тот же базовый класс, что и декорируемые 
		объекты. Поэтому базовый класс Component должен быть по возможности легким и определять только базовый интерфейс.

	Класс декоратора также хранит ссылку на декорируемый объект в виде объекта базового класса Component и реализует связь 
		с базовым классом как через наследование, так и через отношение агрегации.
	Классы ConcreteDecoratorA и ConcreteDecoratorB представляют дополнительные функциональности, которыми должен быть 
		расширен объект ConcreteComponent.
-----------------------------------------------------------------------------------------------------------------------------------
Следствия
	Добавляемая функциональность реализуется в небольших объектах. Преимущество состоит в возможности динамически 
добавлять эту функциональность до или после основной функциональности объекта ConcreteComponent. Позволяет избегать 
перегрузки функциональными классами на верхних уровнях иерархии.	
	Декоратор и его компоненты не являются идентичными.

Реализация
	Создается абстрактный класс, представляющий как исходный класс, так и новые, добавляемые в класс функции. 
В классах-декораторах новые функции вызываются в требуемой последовательности — до или после вызова последующего объекта.
При желании остаётся возможность использовать исходный класс (без расширения функциональности), если на его объект 
сохранилась ссылка.

Замечания и комментарии
	Хотя объект-декоратор может добавлять свою функциональность до или после функциональности основного объекта, 
цепочка создаваемых объектов всегда должна заканчиваться объектом класса ConcreteComponent.
	Базовые классы языка Java широко используют шаблон Декоратор для организации обработки операций ввода-вывода.
	И декоратор, и адаптер являются обёртками вокруг объекта — хранят в себе ссылку на оборачиваемый объект и часто 
передают в него вызовы методов. Отличие декоратора от адаптера в том, что адаптер имеет внешний интерфейс, отличный 
от интерфейса оборачиваемого объекта, и используется именно для стыковки разных интерфейсов. Декоратор же имеет точно 
такой же интерфейс, и используется для добавления функциональности.
	Для расширения функциональности класса возможно использовать как декораторы, так и стратегии. Декораторы оборачивают 
объект снаружи, стратегии же вставляются в него внутрь по неким интерфейсам.
	- Недостаток стратегии: класс должен быть спроектирован с возможностью вставления стратегий, 
	декоратор же не требует такой поддержки.
	- Недостаток декоратора: он оборачивает ровно тот же интерфейс, что предназначен для внешнего мира, что вызывает 
	смешение публичного интерфейса и интерфейса кастомизации, которое не всегда желательно.

Применение шаблона
	Драйверы-фильтры в ядре Windows (архитектура WDM (Windows Driver Model)) представляют собой декораторы. 
Несмотря на то, что WDM реализована на не-объектном языке Си, в ней четко прослеживаются паттерны 
проектирования — декоратор, цепочка обязанностей, и команда (объект IRP).
	Архитектура COM (Component Object Model) не поддерживает наследование реализаций, вместо него предлагается использовать 
декораторы (в данной архитектуре это называется «агрегация»). При этом архитектура решает (с помощью механизма pUnkOuter) 
проблему object identity, возникающую при использовании декораторов — identity агрегата есть identity его самого внешнего 
декоратора. Функционально агрегация уже, чем декоратор. Дело в том, что объект-компонент, на который накладывается аггрегация, 
изначально должен быть т. наз. аггрегируемым, тогда как декоратор в общем случае должен уметь накладываться во время 
выполнения на объект любого происхождения.

-----------------------------------------------------------------------------------------------------------------------------------
Ссылки:
	- https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)
	- https://metanit.com/sharp/patterns/4.1.php
-----------------------------------------------------------------------------------------------------------------------------------
Пример:

using System;

namespace Decorator
{
    class MainApp
    {
        static void Main()
        {
            // Create ConcreteComponent and two Decorators
            ConcreteComponent c = new ConcreteComponent();
            ConcreteDecoratorA dA = new ConcreteDecoratorA();
            ConcreteDecoratorB dB = new ConcreteDecoratorB();

            // Link decorators
            dA.SetComponent(c);
            dB.SetComponent(dA);

            dA.Operation();

            Console.WriteLine();

            dB.Operation();

            // Wait for user
            Console.Read();
        }
    }

    /// <summary>
    /// Component - компонент
    /// </summary>
    /// <remarks>
    /// <li>
    /// <lu>определяем интерфейс для объектов, на которые могут быть динамически 
    /// возложены дополнительные обязанности;</lu>
    /// </li>
    /// </remarks>
    abstract class Component
    {
        public abstract void Operation();
    }

    /// <summary>
    /// ConcreteComponent - конкретный компонент
    /// </summary>
    /// <remarks>
    /// <li>
    /// <lu>определяет объект, на который возлагается дополнительные обязанности</lu>
    /// </li>
    /// </remarks>
    class ConcreteComponent : Component
    {
        public override void Operation()
        {
            Console.Write("Привет");
        }
    }

    /// <summary>
    /// Decorator - декоратор
    /// </summary>
    /// <remarks>
    /// <li>
    /// <lu>хранит ссылку на объект <see cref="Component"/> и определяет интерфейс,
    /// соответствующий интерфейсу <see cref="Component"/></lu>
    /// </li>
    /// </remarks>
    abstract class Decorator : Component
    {
        protected Component component;

        public void SetComponent(Component component)
        {
            this.component = component;
        }

        public override void Operation()
        {
            if (component != null)
            {
                component.Operation();
            }
        }
    }

    /// <summary>
    /// ConcreteDecoratorA - конкретный декоратор
    /// </summary>
    /// <remarks>
    /// <li>
    /// <lu>Выполняет основную задачу</lu>
    /// </li>
    /// </remarks>
    class ConcreteDecoratorA : Decorator
    {
        public override void Operation()
        {
            base.Operation();
        }
    }

    /// <summary>
    /// ConcreteDecorator - конкретный декоратор
    /// </summary>
    /// <remarks>
    /// <li>
    /// <lu>Выполняет основную задачу + дополнительную</lu>
    /// </li>
    /// </remarks>
    class ConcreteDecoratorB : Decorator
    {
        public override void Operation()
        {
            base.Operation();

            Console.Write(" Мир!");
        }
    }
}
	