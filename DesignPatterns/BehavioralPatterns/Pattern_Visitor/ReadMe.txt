	Посетитель (шаблон проектирования)

	Шаблон проектирования - Посетитель (Visitor)
	Тип:	поведенческий.
	
	Назначение:	не изменяя основного класса, добавить в него новые операции.

	Применяется в случаях:	когда необходимо для ряда классов сделать похожую (одну и ту же) операцию.

	Плюсы:	
	- новая функциональность в несколько классов добавляется сразу, не изменяя код этих классов;
	- позволяет получить информацию о типе объекта;
	- двойная диспетчеризация;
	- возможность описания своего алгоритма для каждого типа объектов.
	Минусы:	
	- при изменении обслуживаемого класса нужно поменять код у шаблона;
	- затруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.

	Посетитель (англ. visitor) — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над 
объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.
	Шаблон демонстрирует классический приём восстановления информации о потерянных типах, не прибегая к понижающему приведению типов.

	Решаемая проблема: Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. 
И нет возможности или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем 
выполнить нужную операцию.

	Задача: Над каждым объектом некоторой структуры выполняется одна или более операций. Нужно определить новую операцию, 
не изменяя классы объектов.

	Решение: Для независимости посетитель имеет отдельную иерархию. Структуры имеют некий интерфейс взаимодействия.

	Использование: Если есть вероятность изменения иерархии обслуживаемого класса, либо она будет нестабильной или открытый 
интерфейс достаточно эффективен для доступа шаблона, то его использование будет вредоносным.

	Создается базовый класс Visitor с методами visit() для каждого подкласса родительского Element. Добавьте метод 
accept(visitor) в иерархию Element. Для каждой операции, которая должна выполняться для объектов Element, создайте производный 
от Visitor класс. Реализации метода visit() должны использовать открытый интерфейс класса Element. В результате: клиенты 
создают объекты Visitor и передают их каждому объекту Element, вызывая accept().

	Рекомендации: Шаблон следует использовать, если:
	- имеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции, зависящие от конкретных классов;
	- необходимо над структурой выполнить различные, усложняющие структуру операции;
	- часто добавляются новые операции над структурой.

	Преимущества и недостатки:
	Преимущества:
	- упрощается добавление новых операций;
	- объединение родственных операции в классе Visitor;
	- класс Visitor может запоминать в себе какое-то состояние по ходу обхода контейнера.
	Недостатки:
	- затруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.

	Реализация:
	- Добавьте метод accept(Visitor) в иерархию «элемент».
	- Создайте базовый класс Visitor и определите методы visit() для каждого типа элемента.
	- Создайте производные классы Visitor для каждой операции, исполняемой над элементами.
	- Клиент создаёт объект Visitor и передаёт его в вызываемый метод accept().
--------------------------------------------------------------------------------------------------------------------------------------------
	Участники:
	- Visitor: интерфейс посетителя, который определяет метод Visit() для каждого объекта Element.
	- ConcreteVisitor1 / ConcreteVisitor2: конкретные классы посетителей, реализуют интерфейс, определенный в Visitor.
	- Element: определяет метод Accept(), в котором в качестве параметра принимается объект Visitor.
	- ElementA / ElementB: конкретные элементы, которые реализуют метод Accept().
	- ObjectStructure: некоторая структура, которая хранит объекты Element и предоставляет к ним доступ. Это могут быть 
	и простые списки, и сложные составные структуры в виде деревьев.
--------------------------------------------------------------------------------------------------------------------------------------------
Ссылки:
	- https://ru.wikipedia.org/wiki/Посетитель_(шаблон_проектирования) 
	- https://metanit.com/sharp/patterns/3.11.php 
--------------------------------------------------------------------------------------------------------------------------------------------
public static class Demo
{
	private static void Main()
	{
		Point p = new Point2D(1, 2);
		IVisitor v = new Chebyshev();
		p.Accept(v);
		Console.WriteLine(p.Metric);
	}
}

internal interface IVisitor
{
	void Visit(Point2D p);
	void Visit(Point3D p);
}

internal abstract class Point
{
	public double Metric { get; set; } = -1;
	public abstract void Accept(IVisitor visitor);
}

internal class Point2D : Point
{
	public Point2D(double x, double y)
	{
		X = x;
		Y = y;
	}

	public double X { get; }
	public double Y { get; }

	public override void Accept(IVisitor visitor)
	{
		visitor.Visit(this);
	}
}

internal class Point3D : Point
{
	public Point3D(double x, double y, double z)
	{
		X = x;
		Y = y;
		Z = z;
	}

	public double X { get; }
	public double Y { get; }
	public double Z { get; }

	public override void Accept(IVisitor visitor)
	{
		visitor.Visit(this);
	}
}

internal class Euclid : IVisitor
{
	public void Visit(Point2D p)
	{
		p.Metric = Math.Sqrt(p.X*p.X + p.Y*p.Y);
	}

	public void Visit(Point3D p)
	{
		p.Metric = Math.Sqrt(p.X*p.X + p.Y*p.Y + p.Z*p.Z);
	}
}

internal class Chebyshev : IVisitor
{
	public void Visit(Point2D p)
	{
		var ax = Math.Abs(p.X);
		var ay = Math.Abs(p.Y);
		p.Metric = ax > ay ? ax : ay;
	}

	public void Visit(Point3D p)
	{
		var ax = Math.Abs(p.X);
		var ay = Math.Abs(p.Y);
		var az = Math.Abs(p.Z);
		var max = ax > ay ? ax : ay;
		if (max < az) max = az;
		p.Metric = max;
	}
}
--------------------------------------------------------------------------------------------------------------------------------------------