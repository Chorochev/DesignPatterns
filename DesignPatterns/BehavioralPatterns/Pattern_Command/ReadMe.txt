Команда (шаблон проектирования)

Шаблон проектирования - Команда (Command)

Тип:	поведенческий.
Назначение:	для обработки команды в виде объекта.
Родственные шаблоны: Компоновщик, Хранитель, Прототип, Одиночка.

	Команда (англ. Command) — поведенческий шаблон проектирования, используемый при объектно-ориентированном 
программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.

	Цель: Создание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую. 
Организация обратного вызова к классу, который включает в себя класс-отправитель.

	Описание
В объектно-ориентированном программировании шаблон проектирования Команда является поведенческим шаблоном, в 
котором объект используется для инкапсуляции всей информации, необходимой для выполнения действия или вызова 
события в более позднее время. Эта информация включает в себя имя метода, объект, который является владельцем 
метода и значения параметров метода.

Четыре термина всегда связанны с шаблоном Команда: 
	1. команды (command), 
	2. приёмник команд (receiver), 
	3. вызывающий команды (invoker) и 
	4. клиент (client). 
Объект Command знает о приёмнике и вызывает метод приемника. Значения параметров приёмника сохраняются в команде. 
Вызывающий объект (invoker) знает, как выполнить команду и, возможно, делает учёт и запись выполненных команд. 
Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает только об интерфейсе. Оба объекта 
(вызывающий объект и несколько объектов команд) принадлежат объекту клиента (client). Клиент решает, какие команды 
выполнить и когда. Чтобы выполнить команду он передает объект команды вызывающему объекту (invoker).

	Использование командных объектов упрощает построение общих компонентов, которые необходимо делегировать или 
выполнять вызовы методов в любое время без необходимости знать методы класса или параметров метода. Использование 
вызывающего объекта (invoker) позволяет ввести учёт выполненных команд без необходимости знать клиенту об этой модели 
учёта (такой учёт может пригодиться, например, для реализации отмены и повтора команд).

Применение: Шаблон Команда может быть полезен в следующих случаях. 
	- Кнопки пользовательского интерфейса и пункты меню.
	В Swing и Borland Delphi Action (действие) является объектом команды. В дополнение к способности выполнить нужную команду, 
	Action может иметь связанную с ним иконку, сочетание клавиш, текст всплывающей подсказки и так далее. Кнопка на панели 
	инструментов или пункт меню могут быть полностью инициализированы с использованием только объекта Action.

	- Запись макросов
	Если все действия пользователя представлены в виде объектов команды, программа может записать последовательность 
	действий, просто сохраняя список командных объектов в том порядке, в котором они выполняются. Затем она может 
	«воспроизвести» одни и те же действия, выполняя те же объекты команд в той же последовательности.

	- Многоуровневая отмена операций (Undo)
	Если все действия пользователя в программе реализованы в виде командных объектов, программа может сохранить стек последних 
	выполненных команд. Когда пользователь хочет отменить команду, программа просто выталкивает последний объект команды и 
	выполняет его метод undo().

	- Сети
	Можно отправить объекты команд по сети для выполнения на другой машине, например действие игрока в компьютерной игре.

	- Индикаторы выполнения
	Предположим, что программа имеет последовательность команд, которые она выполняет по порядку. Если каждый объект команды 
	имеет метод getEstimatedDuration() (получить оценочную длительность), программа может легко оценить общую продолжительность 
	процесса. Она может показать индикатор выполнения, который отражает, насколько близка программа к завершению всех задач.

	- Пулы потоков
	Типичный класс пула потоков общего назначения может иметь метод addTask(), который добавляет рабочий элемент к внутренней 
	очереди заданий ожидающих своего выполнения. Он поддерживает пул потоков, которые выполняют команды из очереди. Элементы 
	в очереди являются объектами команд. Как правило, эти объекты реализуют общий интерфейс, такой как java.lang.Runnable, 
	что позволяет пулу потоков запустить команды на выполнение, даже если он сам был написан без каких-либо знаний о конкретных 
	задачах, для которых он будет использоваться.

	- Транзакции
	Аналогично операции «отмена» система управления базами данных (СУБД) или установщик программного обеспечения может хранить 
	список операций, которые были или будут выполнены. Если одна из них закончится неудачей, то все остальные могут быть отменены 
	или быть отброшены (обычно называется откат). Например, если две связанные между собой таблицы базы данных должны быть обновлены, 
	а второе обновление терпит неудачу, то транзакция может быть откачена, чтобы первая таблица не содержала недопустимую ссылку.

	- Мастера
	Часто мастер (мастер установки или любой другой) представляет несколько страниц конфигурации для одного действия, которое происходит 
	только тогда, когда пользователь нажимает на кнопку «Готово» на последней странице. В этих случаях, естественный способ отделить 
	код пользовательского интерфейса от кода приложения является реализация мастера с помощью объекта команд. Объект команда создается 
	при первом отображении мастера. Каждая страница мастера сохраняет свои изменения в объекте команды, поэтому объект заполняется 
	по мере перехода пользователя. Кнопка «Готово» просто запускает метод execute() на выполнение.

-----------------------------------------------------------------------------------------------------------------------------------------
Участники
	- Command: интерфейс, представляющий команду. Обычно определяет метод Execute() для выполнения действия, а также нередко 
	включает метод Undo(), реализация которого должна заключаться в отмене действия команды.

	- ConcreteCommand: конкретная реализация команды, реализует метод Execute(), в котором вызывается определенный метод, 
	определенный в классе Receiver.

	- Receiver: получатель команды. Определяет действия, которые должны выполняться в результате запроса.

	- Invoker: инициатор команды - вызывает команду для выполнения определенного запроса.

	- Client: клиент - создает команду и устанавливает ее получателя с помощью метода SetCommand().
-----------------------------------------------------------------------------------------------------------------------------------------
Ссылки:
	- https://ru.wikipedia.org/wiki/Команда_(шаблон_проектирования) 
	- https://metanit.com/sharp/patterns/3.3.php
-----------------------------------------------------------------------------------------------------------------------------------------
Пример

using System;
using System.Collections.Generic;

namespace Command
{

  class MainApp
  {
    static void Main()
    {
      // Создаем пользователя.
      User user = new User();

      // Пусть он что-нибудь сделает.
      user.Compute('+', 100);
      user.Compute('-', 50);
      user.Compute('*', 10);
      user.Compute('/', 2);

      // Отменяем 4 команды
      user.Undo(4);

      // Вернём 3 отменённые команды.
      user.Redo(3);

      // Ждем ввода пользователя и завершаемся.
      Console.Read();
    }
  }

  // "Command" : абстрактная Команда

  abstract class Command
  {
    public abstract void Execute();
    public abstract void UnExecute();
  }

  // "ConcreteCommand" : конкретная команда

  class CalculatorCommand : Command
  {
    char @operator;
    int operand;
    Calculator calculator;

    // Constructor
    public CalculatorCommand(Calculator calculator,
      char @operator, int operand)
    {
      this.calculator = calculator;
      this.@operator = @operator;
      this.operand = operand;
    }

    public char Operator
    {
      set{ @operator = value; }
    }

    public int Operand
    {
      set{ operand = value; }
    }

    public override void Execute()
    {
      calculator.Operation(@operator, operand);
    }

    public override void UnExecute()
    {
      calculator.Operation(Undo(@operator), operand);
    }

    // Private helper function : приватные вспомогательные функции
    private char Undo(char @operator)
    {
      char undo;
      switch(@operator)
      {
        case '+': undo = '-'; break;
        case '-': undo = '+'; break;
        case '*': undo = '/'; break;
        case '/': undo = '*'; break;
        default : undo = ' '; break;
      }
      return undo;
    }
  }

  // "Receiver" : получатель

  class Calculator
  {
    private int curr = 0;

    public void Operation(char @operator, int operand)
    {
      switch(@operator)
      {
        case '+': curr += operand; break;
        case '-': curr -= operand; break;
        case '*': curr *= operand; break;
        case '/': curr /= operand; break;
      }
      Console.WriteLine(
        "Current value = {0,3} (following {1} {2})",
        curr, @operator, operand);
    }
  }

  // "Invoker" : вызывающий

  class User
  {
    // Initializers
    private Calculator _calculator = new Calculator();
    private List<Command> _commands = new List<Command>();

    private int _current = 0;

    public void Redo(int levels)
    {
      Console.WriteLine("\n---- Redo {0} levels ", levels);

      // Делаем возврат операций
      for (int i = 0; i < levels; i++)
        if (_current < _commands.Count)
          _commands[_current++].Execute();
    }

    public void Undo(int levels)
    {
      Console.WriteLine("\n---- Undo {0} levels ", levels);

      // Делаем отмену операций
      for (int i = 0; i < levels; i++)
        if (_current > 0)
          _commands[--_current].UnExecute();
    }

    public void Compute(char @operator, int operand)
    {

      // Создаем команду операции и выполняем её
      Command command = new CalculatorCommand(
        _calculator, @operator, operand);
      command.Execute();

	if (_current < _commands.Count)
	{
	    // если "внутри undo" мы запускаем новую операцию, 
	    // надо обрубать список команд, следующих после текущей, 
	    // иначе undo/redo будут некорректны
		_commands.RemoveRange(_current, _commands.Count - _current);
	}

      // Добавляем операцию к списку отмены
      _commands.Add(command);
      _current++;
    }
  }
}
-----------------------------------------------------------------------------------------------------------------------------------------