	Стратегия (шаблон проектирования)

	Шаблон проектирования Стратегия (Strategy)
	Тип:	поведенческий.
	Назначение:	позволяет использовать различные бизнес-правила или алгоритмы в зависимости от контекста.

	Применяется в случаях:	когда в одном и том же месте в зависимости от текущего состояния системы (или её 
окружения) должны использоваться различные алгоритмы

	Плюсы:	
	- инкапсуляция реализации различных алгоритмов, система становится независимой от возможных изменений бизнес-правил;
	- вызов всех алгоритмов одним стандартным образом;
	- отказ от использования переключателей и/или условных операторов.
	Минусы:	
	- создание дополнительных классов.

Родственные шаблоны: Мост, Шаблонный метод, Адаптер.

	Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства 
алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём 
определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, 
которые его используют.

	Основные характеристики.
	Задача: По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить. 
Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».

	Мотивы.
	- Программа должна обеспечивать различные варианты алгоритма или поведения.
	- Нужно изменять поведение каждого экземпляра класса.
	- Необходимо изменять поведение объектов на стадии выполнения.
	- Введение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и 
	инкапсулирующих в себе конкретные алгоритмы.

	Способ решения: Отделение процедуры выбора алгоритма от его реализации. Это позволяет сделать выбор на основании контекста.

	Участники:
	- Класс Strategy определяет, как будут использоваться различные алгоритмы.
	- Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.
	- Класс Context использует конкретные классы ConcreteStrategy посредством ссылки на конкретный тип абстрактного 
	класса Strategy. Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма (в некоторых 
	случаях классу Strategy требуется посылать запросы классу Context). Класс Context пересылает классу Strategy запрос, 
	поступивший от его класса-клиента.

	Следствия:
	- Шаблон Strategy определяет семейство алгоритмов.
	- Это позволяет отказаться от использования переключателей и/или условных операторов.
	- Вызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь одинаковый интерфейс).

	Реализация: Класс, который использует алгоритм (Context), включает абстрактный класс (Strategy), обладающий абстрактным 
методом, определяющим способ вызова алгоритма. Каждый производный класс реализует один требуемый вариант алгоритма.

	Замечание: метод вызова алгоритма не должен быть абстрактным, если требуется реализовать некоторое поведение, 
принимаемое по умолчанию.

	Полезные сведения: и стратегия, и декоратор могут применяться для изменения поведения конкретных классов. Достоинство 
стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более удобным, а 
недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.

	Использование: Архитектура Microsoft WDF основана на этом паттерне. У каждого объекта «драйвер» и «устройство» есть 
неизменяемая часть, вшитая в систему, в которой регистрируется изменяемая часть (стратегия), написанная в конкретной реализации. 
Изменяемая часть может быть и вовсе пустой, что даст ничего не делающий драйвер, но при этом способный участвовать в PnP и 
управлении питанием.

	Библиотека ATL содержит в себе набор классов threading model, которые являются стратегиями (различными реализациями 
Lock/Unlock, которые потом используются основными классами системы). При этом в этих стратегиях используется статический 
полиморфизм через параметр шаблона, а не динамический полиморфизм через виртуальные методы.
---------------------------------------------------------------------------------------------------------------------
Ссылки:
	- https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования) 
	- https://metanit.com/sharp/patterns/3.1.php
---------------------------------------------------------------------------------------------------------------------
Пример

using System;

namespace DesignPatterns.Behavioral.Strategy
{
    // Класс реализующий конкретную стратегию, должен наследовать этот интерфейс
    // Класс контекста использует этот интерфейс для вызова конкретной стратегии
    public interface IStrategy
    {
        void Algorithm();
    }

    // Первая конкретная реализация-стратегия.
    public class ConcreteStrategy1 : IStrategy
    {
        public void Algorithm()
        {
            Console.WriteLine("Выполняется алгоритм стратегии 1.");
        }
    }

    // Вторая конкретная реализация-стратегия.
    // Реализаций может быть сколько угодно много.
    public class ConcreteStrategy2 : IStrategy
    {
        public void Algorithm()
        {
            Console.WriteLine("Выполняется алгоритм стратегии 2.");
        }
    }

    // Контекст, использующий стратегию для решения своей задачи.
    public class Context
    {
        // Ссылка на интерфейс IStrategy
        // позволяет автоматически переключаться между конкретными реализациями
        // (другими словами, это выбор конкретной стратегии).
        private IStrategy _strategy;

        // Конструктор контекста.
        // Инициализирует объект стратегией.
        public Context(IStrategy strategy)
        {
            _strategy = strategy;
        }

        // Метод для установки стратегии.
        // Служит для смены стратегии во время выполнения.
        // В C# может быть реализован также как свойство записи.
        public void SetStrategy(IStrategy strategy)
        {
            _strategy = strategy;
        }

        // Некоторая функциональность контекста, которая выбирает
        //стратегию и использует её для решения своей задачи.
        public void ExecuteOperation()
        {
            _strategy.Algorithm();
        }
    }

    // Класс приложения.
    // В данном примере выступает как клиент контекста.
    public static class Program
    {
        // <summary>
        // Точка входа в программу.
        // </summary>
        public static void Main()
        {
            // Создаём контекст и инициализируем его первой стратегией.
            Context context = new Context(new ConcreteStrategy1());
            // Выполняем операцию контекста, которая использует первую стратегию.
            context.ExecuteOperation();
            // Заменяем в контексте первую стратегию второй.
            context.SetStrategy(new ConcreteStrategy2());
            // Выполняем операцию контекста, которая теперь использует вторую стратегию.
            context.ExecuteOperation();
        }
    }
}
---------------------------------------------------------------------------------------------------------------------